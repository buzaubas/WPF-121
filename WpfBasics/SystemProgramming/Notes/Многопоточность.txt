Многопоточность
Параллельное программирование (укр.- багатониткове)
 - многопоточное: с использованием потоков (как системных ресурсов)
 - многозадачное: с использованием задач (как объектов языка программирования)

Отличительной чертой параллельности является отсутствие прогнозированного порядка
выполнения кода. Если от запуска к запуску порядок выполнения всегда один и тот же,
то это косвенный признак плохо организованной параллельности.
С другой стороны изменчивый порядок требует перепланирования алгоритмов решения
задач - с применением действий, не зависящих от порядка выполнения

Термин "синхронный" противопоставляется параллельному, асинхронному

Пример - расчет годовой инфляции. Минфин публикует ежемесячные показатели, а наша
задача провести расчет итога за год
В синхронном стиле: 100 (+10% за январь) -> 110 (+5% за февраль) -> 115.5 (+...)
Анализ на возможность асинхронности:
(100 + 10%) + 5%  =?= (100 + 5%) + 10%
 +10% == x1.1    +5% == x1.05
(100 x 1.1) x 1.05  =?= (100 x 1.05) x 1.1   да, ==
равенство означает то, что порядок операций не играет роли и можно использовать
асинхронный подход

Проблемы многопоточности
1. Необходимость работы на общий ресурс требует выделения "глобальной" переменной
2. Неизбежная разница во времени от чтения значения переменной до записи ее нового значения

Thread1         Sum            Thread2
sum = Sum		100			   sum = Sum   // и в Thread1, и в Thread2 sum = 100
.... 						   ....
Sum = sum ----> 110			   ....
				107 <--------- Sum = sum

В поиске решения этой проблемы появлялись идеи атомарных типов данных,
блокировки потока, организации транзакций и т.п. Общий термин для этой ситуации - 
"синхронизация" потоков либо "потокобезопасность"

Для задач синхронизации каждый из объектов (ссылочный тип) содержит в своем составе
"критическую секцию" - системный примитив синхронизации.
блок 
lock(obj) { ... код ... }
переводит объект obj (его критическую секцию) в "закрытое" состояние, это значит, 
что другие потоки, содержащие блок lock(obj) (с тем же объектом) не будут выполняться
до тех пор, пока объект не будет разблокирован.
Разблокировка происходит автоматически после завершения ...кода...

Thread1      obj       Thread2
start 		  +		   start       // общая часть выполняется параллельно
lock(obj){--> -	<----- lock(obj){  // отказ - объект заблокирован первым потоком
  body				     ....      // переход в режим ожидания разблокировки
  coef(Sleep)
} ----------> + ------>            // сигнал открытия объекта
              - <----------------- //  блокируется этим потоком
                         body
                         coef(Sleep) 
              + <----- }

 Другая сторона проблемы - если всё тело потового метода блокировать (помещать в lock),
то теряется эффект многопоточности: все потоки запущены и стоят в ожидающем состоянии.
Реально выполняется только один из них
 Решение хуже, чем однопоточное - во времени выигрыша нет, а использование ресурсов
огромное - много потоков и все в режиме ожидания.

 Блок lock должен быть минимально возможным и блокировать только транзакцию
от чтения до записи

Thread1      obj       Thread2
start 		  +		   start         // общая часть выполняется параллельно
coef(Sleep)   +        coef(Sleep)   // это тоже параллельно
lock(obj){--> -	       coef(Sleep)   // 2й ожидает чуть дольше  - lock не мешает работе
              - <----- lock(obj){  // отказ - объект заблокирован первым потоком
  body				     ....      // переход в режим ожидания разблокировки
} ----------> + ------>            // сигнал открытия объекта
              - <----------------- //  блокируется этим потоком
                         body
              + <----- }

Определение последнего потока
Поскольку порядок выполнения потоков непредсказуемый, задача определения последнего
из них представляет определенную сложность.
 - можно ожидать завершения всех потоков (потребуется хранить все Thread в массиве)
 - использовать счетчик активных потоков

Выводы:
 - при работе с общими ресурсами необходима синхронизация. Это упредит возможность
    одновременного доступа к ресурсу из разных потоков (concurence)
 - для синхронизации можно использовать как сами объекты-ресурсы, так и отдельные
    объекты, созданные для этих целей.
    = значимые типы нельзя использовать, у них нет критической секции
    = если использовать тот же объект, то важно убедиться, что объект не
       изменится в теле блока
         String str                         lock( str )  -- str заблокирован
         ...                                str += "..." -- str = new ( str + "..." )
         lock(str) { str += "..." }         новый str - не заблокирован

      рекомендация - для синхронизации использовать константные (readonly) объекты

Д.З. Пользователь вводит число (например 20)
программа рассчитывает сумму всех чисел от 1 до введенного 
добавление каждого слагаемого реализовать в отдельном потоке
обеспечить вывод "журнала" в виде
 step 1   add 5    total 5
 step 2   add 7    total 12
 step 3   add 1    total 13
 .......................
 step 20  add 18   total 105
 --- result 105
по окончанию всех потоков вывести итоговый результат