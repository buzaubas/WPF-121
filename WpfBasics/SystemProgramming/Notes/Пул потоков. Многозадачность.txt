Пул потоков.
Потоки (сами-по-себе) равноправные участники вычислительного процесса,
Пул потоков обеспечивает работу потоков в "подчиненном" режиме
 - потоки имеют низший (фоновый) приоритет (заметно только при нагруженной системе)
 - потоки разрушаются при разрушении главного потока
 + пул регулирует кол-во одновременно работающих потоков, выравнивая нагрузку

Требование к потоковым методам - такое же, как и для обычных потоков
Добавление на выполнение:
 ThreadPool - статический, создавать new ThreadPool не нужно
 ThreadPool.QueueUserWorkItem(Метод); - дополнительного .Start() не нужно,
 метод сразу планируется на выполнение
 ThreadPool.QueueUserWorkItem(Метод, object); - передача object в параметры метода

------ Многозадачность ----------
Развитие идеи многопоточности привело к поялению задач (Task-C#, Promise-JS, Future-Java)
Основные неудобства потоков:
 - нет возврата, приходится использовать "общие ресурсы"
 - однотипность аргумента и невозможность нескольких аргументов

Запуск обычных методов
Task t1 = new Task( 		 | Полная схожесть с потоком, но вместо ссылки на метод
	()=>TaskMethod1(20) 	 | можно передать Action / Lambda 
);							 | 
t1.Start();					 | Требует отдельного запуска

Task t2 = Task.Run(			 | Вариант с мгновенным запуском
	() => TaskMethod0(10)	 | 
);							 | 
													  Между запуском первой задачи
											 и ее окончанием можно выполнять действия
t1.Wait();   				 | Ожидание окончания первой задачи |
							 | Если t1 завершилась к этой строке, то игнорируется

Task.Run(() => TaskMethod0(30));  эта инструкция выполнится после окончания t1

======== Задачи с возвратом ================
							| Task<TResult> - перегрузка с возвратом TResult
Task<String> t = 			| Task<String> - ожидает возврат String
  Task.Run(					| t - задача (Task), на методе с возратом String
	() => TaskMethod1(40)	| Метод получает int, формирует и возвращает строку
);							| 
Log2.Text = t.Result;		| t.Result - ожидание (Wait) плюс извлечение рез-та (строки)